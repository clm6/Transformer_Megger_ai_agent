#!/usr/bin/env python3
"""
JSON-to-Report Generator v3.0
Purpose: Generate comprehensive reports directly from rich JSON data
Utilizes all detailed analysis data instead of generic summaries
"""

import json
import os
from datetime import datetime

def generate_detailed_report_from_json(json_file_path, output_file_path):
    """
    Generate a comprehensive report directly from JSON data
    Utilizes all detailed component data, values, and analysis
    """
    
    with open(json_file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    # Extract metadata
    metadata = data.get('report_metadata', {})
    
    # Build comprehensive report
    report_lines = []
    
    # Header
    report_lines.extend([
        "=" * 80,
        "üîç TRAX AI ANALYZER v3.0 - COMPREHENSIVE DIAGNOSTIC REPORT",
        "=" * 80,
        f"üìÑ Equipment: {metadata.get('file_name', 'Unknown')}",
        f"üìÖ Document Date: {metadata.get('document_date', 'Unknown')}",
        f"üî¨ Analysis Date: {metadata.get('analysis_date', 'Unknown')}",
        f"ü§ñ Generated By: {metadata.get('generated_by', 'TRAX AI Analyzer v3.0')}",
        f"‚ö° Analysis Type: {metadata.get('analysis_type', 'Standard Analysis')}",
        "",
        "=" * 80,
        ""
    ])
    
    # Asset Health Score (if available)
    if 'asset_health_score' in data:
        ahs = data['asset_health_score']
        report_lines.extend([
            "üß† ASSET HEALTH SCORE",
            "-" * 40,
            f"Overall Score: {ahs.get('calculated_score', 'N/A')}/100",
            f"Condition: {ahs.get('condition_category', 'Unknown')}",
            f"Degradation Trend: {ahs.get('degradation_trend', 'Unknown')}",
            f"Estimated Remaining Life: {ahs.get('estimated_remaining_life', 'Unknown')} years",
            "",
            "Component Breakdown:",
            f"  ‚Ä¢ Winding Resistance: {ahs.get('component_scores', {}).get('winding_resistance', 'N/A')} pts",
            f"  ‚Ä¢ Turns Ratio: {ahs.get('component_scores', {}).get('turns_ratio', 'N/A')} pts",
            f"  ‚Ä¢ Main Insulation: {ahs.get('component_scores', {}).get('main_insulation', 'N/A')} pts",
            f"  ‚Ä¢ Bushing PF: {ahs.get('component_scores', {}).get('bushing_pf', 'N/A')} pts",
            f"  ‚Ä¢ Demagnetization: {ahs.get('component_scores', {}).get('demagnetization', 'N/A')} pts",
            "",
            "=" * 80,
            ""
        ])
    
    # Winding Resistance Analysis
    if 'winding_resistance' in data:
        wr = data['winding_resistance']
        report_lines.extend([
            "‚ö° WINDING RESISTANCE ANALYSIS",
            "-" * 40,
            ""
        ])
        
        # LV Windings
        if 'lv_windings' in wr and wr['lv_windings']:
            report_lines.append("LV Windings:")
            for winding in wr['lv_windings']:
                report_lines.append(
                    f"  ‚Ä¢ {winding.get('phase', 'Unknown')}: {winding.get('resistance_mohm', 'N/A')} mŒ© "
                    f"(Range: {winding.get('range_mohm', 'N/A')} mŒ©) {winding.get('status', '')} "
                    f"[Confidence: {winding.get('confidence_score', 'N/A')}%]"
                )
            report_lines.append("")
        
        # HV Windings
        if 'hv_windings' in wr and wr['hv_windings']:
            report_lines.append("HV Windings:")
            for winding in wr['hv_windings']:
                report_lines.append(
                    f"  ‚Ä¢ {winding.get('phase', 'Unknown')}: {winding.get('resistance_ohm', 'N/A')} Œ© "
                    f"(Range: {winding.get('range_ohm', 'N/A')} Œ©) {winding.get('status', '')} "
                    f"[Confidence: {winding.get('confidence_score', 'N/A')}%]"
                )
            report_lines.append("")
        
        report_lines.extend(["", "=" * 80, ""])
    
    # Turns Ratio Analysis
    if 'turns_ratio' in data:
        ttr = data['turns_ratio']
        report_lines.extend([
            "üîÑ TURNS RATIO ANALYSIS",
            "-" * 40,
            ""
        ])
        
        # Handle both list and dict formats
        ttr_data = ttr
        if isinstance(ttr, dict) and 'measurements' in ttr:
            ttr_data = ttr['measurements']
        
        if isinstance(ttr_data, list):
            for measurement in ttr_data:
                report_lines.extend([
                    f"Tap Position: {measurement.get('tap_position', 'Unknown')}",
                    f"  ‚Ä¢ Nominal TTR: {measurement.get('nominal_ttr', 'N/A')}",
                    f"  ‚Ä¢ Measured TTR: {measurement.get('measured_ttr', 'N/A')}",
                    f"  ‚Ä¢ Error: {measurement.get('error_percent', 'N/A')}% {measurement.get('status', '')}",
                    f"  ‚Ä¢ Excitation Current: {measurement.get('excitation_current_ma', 'N/A')} mA",
                    f"  ‚Ä¢ Phase Displacement: {measurement.get('phase_displacement_deg', 'N/A')}¬∞",
                    f"  ‚Ä¢ Confidence: {measurement.get('confidence_score', 'N/A')}%",
                    ""
                ])
        
        report_lines.extend(["", "=" * 80, ""])
    
    # Tan Delta / Main Insulation
    if 'tan_delta_main_insulation' in data:
        td = data['tan_delta_main_insulation']
        report_lines.extend([
            "üî¨ TAN DELTA / MAIN INSULATION ANALYSIS",
            "-" * 40,
            f"Extraction Method: {td.get('extraction_method', 'Standard')}",
            ""
        ])
        
        # Analyze each insulation component
        for component in ['CHL', 'CLG', 'CLH', 'CHG']:
            if component in td:
                comp_data = td[component]
                report_lines.extend([
                    f"{component}:",
                    f"  ‚Ä¢ Power Factor (20¬∞C): {comp_data.get('pf_corrected_20c_percent', 'N/A')}%",
                    f"  ‚Ä¢ Status: {comp_data.get('status', 'Unknown')} {comp_data.get('visual_indicator', '')}",
                    f"  ‚Ä¢ Temperature Correction: {comp_data.get('temperature_correction', 'N/A')}",
                    f"  ‚Ä¢ Confidence: {comp_data.get('confidence_score', 'N/A')}%",
                    f"  ‚Ä¢ Monitoring: {comp_data.get('monitoring_recommendation', 'Standard')}",
                    ""
                ])
                
                # Special flags
                if comp_data.get('moisture_risk_flag'):
                    report_lines.append(f"  ‚ö†Ô∏è MOISTURE RISK FLAG: {comp_data.get('moisture_risk_flag')}")
                if comp_data.get('moisture_combination_flag'):
                    report_lines.append(f"  ‚ö†Ô∏è MOISTURE COMBINATION FLAG: {comp_data.get('moisture_combination_flag')}")
        
        # Pattern Detection
        if 'pattern_detection' in td:
            pattern = td['pattern_detection']
            report_lines.extend([
                "",
                "Pattern Detection Results:",
                f"  ‚Ä¢ Moisture Risk Detected: {pattern.get('moisture_risk_detected', 'False')}",
                f"  ‚Ä¢ Confidence Inheritance: {pattern.get('confidence_inheritance', 'N/A')}",
                ""
            ])
        
        report_lines.extend(["", "=" * 80, ""])
    
    # Bushing Power Factor Analysis
    if 'bushing_pf_c1' in data:
        bpf = data['bushing_pf_c1']
        report_lines.extend([
            "üîå BUSHING POWER FACTOR ANALYSIS",
            "-" * 40,
            f"Extraction Method: {bpf.get('extraction_method', 'Standard')}",
            ""
        ])
        
        # Analyze each bushing
        for bushing in ['H1', 'H2', 'H3', 'X0', 'X1', 'X2', 'X3']:
            if bushing in bpf:
                bushing_data = bpf[bushing]
                report_lines.extend([
                    f"{bushing_data.get('designation', bushing)}:",
                    f"  ‚Ä¢ PF (Test Temp): {bushing_data.get('pf_test_temp_percent', 'N/A')}%",
                    f"  ‚Ä¢ PF (Corrected 20¬∞C): {bushing_data.get('pf_corrected_20c_percent', 'N/A')}%",
                    f"  ‚Ä¢ Status: {bushing_data.get('status', 'Unknown')} {bushing_data.get('visual_indicator', '')}",
                    f"  ‚Ä¢ Confidence: {bushing_data.get('confidence_score', 'N/A')}%",
                    ""
                ])
                
                # Special recommendations
                if bushing_data.get('monitoring_recommendation'):
                    report_lines.append(f"  üìã Recommendation: {bushing_data.get('monitoring_recommendation')}")
                if bushing_data.get('phase_stress_pattern'):
                    report_lines.append(f"  ‚ö†Ô∏è Phase Stress Pattern: {bushing_data.get('phase_stress_pattern')}")
        
        # Cluster Analysis
        if 'cluster_analysis' in bpf:
            cluster = bpf['cluster_analysis']
            report_lines.extend([
                "",
                "üîç CLUSTER ANALYSIS:",
                f"  ‚Ä¢ HV Cluster Degradation: {cluster.get('hv_cluster_degradation', 'False')}",
                f"  ‚Ä¢ LV Cluster Degradation: {cluster.get('lv_cluster_degradation', 'False')}",
                f"  ‚Ä¢ Critical Bushings Count: {cluster.get('critical_bushings_count', '0')}",
                f"  ‚Ä¢ Immediate Action Required: {cluster.get('immediate_action_required', 'False')}",
                f"  ‚Ä¢ Cluster Pattern: {cluster.get('cluster_pattern', 'None')}",
                f"  ‚Ä¢ Overall Bushing Health: {cluster.get('overall_bushing_health', 'Unknown')}",
                ""
            ])
        
        report_lines.extend(["", "=" * 80, ""])
    
    # Demagnetization Analysis
    if 'demagnetization' in data:
        demag = data['demagnetization']
        report_lines.extend([
            "üß≤ DEMAGNETIZATION ANALYSIS",
            "-" * 40,
            f"Initial Remanence: {demag.get('initial_remanence_percent', 'N/A')}%",
            f"Final Remanence: {demag.get('final_remanence_percent', 'N/A')}%",
            f"Effectiveness: {demag.get('effectiveness', 'Unknown')}",
            f"Validation Logic: {demag.get('validation_logic', 'Standard')}",
            f"Confidence: {demag.get('confidence_score', 'N/A')}%",
            "",
            f"Effectiveness Criteria: {demag.get('effectiveness_criteria', 'Standard logic')}",
            "",
            "=" * 80,
            ""
        ])
    
    # Predictive Maintenance Plan
    if 'predictive_maintenance_plan' in data:
        pmp = data['predictive_maintenance_plan']
        report_lines.extend([
            "üîß PREDICTIVE MAINTENANCE PLAN",
            "-" * 40,
            f"Anomaly Score: {pmp.get('anomaly_score', 'N/A')}/10",
            ""
        ])
        
        # Immediate Actions
        if 'immediate_actions' in pmp and pmp['immediate_actions']:
            report_lines.append("üö® IMMEDIATE ACTIONS:")
            for action in pmp['immediate_actions']:
                report_lines.append(f"  ‚Ä¢ {action}")
            report_lines.append("")
        
        # Next Maintenance Interval
        if 'next_maintenance_interval' in pmp:
            interval = pmp['next_maintenance_interval']
            report_lines.extend([
                "üìÖ NEXT MAINTENANCE INTERVAL:",
                f"  ‚Ä¢ Timeframe: {interval.get('recommended_timeframe', 'Unknown')}",
                f"  ‚Ä¢ Components to Monitor: {interval.get('components_to_monitor', 'Standard')}",
                f"  ‚Ä¢ Required Tests: {interval.get('tests_required', 'Standard')}",
                ""
            ])
        
        # Quarterly Monitoring
        if 'quarterly_monitoring' in pmp and pmp['quarterly_monitoring']:
            report_lines.append("üìä QUARTERLY MONITORING:")
            for item in pmp['quarterly_monitoring']:
                report_lines.append(f"  ‚Ä¢ {item}")
            report_lines.append("")
        
        # Replacement Forecast
        if 'replacement_forecast' in pmp:
            forecast = pmp['replacement_forecast']
            report_lines.extend([
                "üîÑ REPLACEMENT FORECAST:",
                f"  ‚Ä¢ High Priority (0-12 months): {forecast.get('high_priority', 'None')}",
                f"  ‚Ä¢ Medium Priority (12-24 months): {forecast.get('medium_priority', 'None')}",
                f"  ‚Ä¢ Long Term (3-5 years): {forecast.get('long_term', 'None')}",
                f"  ‚Ä¢ Estimated Costs: {forecast.get('estimated_costs', 'Unknown')}",
                ""
            ])
        
        # Risk Factors
        if 'risk_factors' in pmp and pmp['risk_factors']:
            report_lines.append("‚ö†Ô∏è IDENTIFIED RISK FACTORS:")
            for risk in pmp['risk_factors']:
                report_lines.append(f"  ‚Ä¢ {risk}")
            report_lines.append("")
        
        report_lines.extend(["", "=" * 80, ""])
    
    # Final Health Assessment
    if 'health_assessment_technical_complete' in data:
        health = data['health_assessment_technical_complete']
        report_lines.extend([
            "üìã FINAL HEALTH ASSESSMENT",
            "-" * 40,
            f"Overall Status: {health.get('overall_status', 'Unknown')} {health.get('visual_status', '')}",
            f"Risk Level: {health.get('risk_level', 'Unknown')}",
            f"Critical Findings Count: {health.get('critical_findings_count', '0')}",
            f"Warning Findings Count: {health.get('warning_findings_count', '0')}",
            f"Immediate Action Flag: {health.get('immediate_action_auto_flag', 'False')}",
            f"Overall Confidence: {health.get('confidence_score_overall', 'N/A')}%",
            ""
        ])
        
        # Pattern Alerts
        if 'pattern_alerts' in health and health['pattern_alerts']:
            report_lines.append("üö® PATTERN ALERTS:")
            for alert in health['pattern_alerts']:
                report_lines.append(f"  ‚Ä¢ {alert}")
            report_lines.append("")
        
        # Cluster Auto-Flagging
        if 'cluster_auto_flagging' in health:
            cluster_flag = health['cluster_auto_flagging']
            report_lines.extend([
                "üîç CLUSTER AUTO-FLAGGING:",
                f"  ‚Ä¢ HV Cluster Critical: {cluster_flag.get('hv_cluster_critical', 'False')}",
                f"  ‚Ä¢ LV Cluster Critical: {cluster_flag.get('lv_cluster_critical', 'False')}",
                f"  ‚Ä¢ Immediate Replacement Recommended: {cluster_flag.get('immediate_replacement_recommended', 'False')}",
                ""
            ])
        
        # Technical Completeness
        if 'technical_completeness_validation' in health:
            completeness = health['technical_completeness_validation']
            report_lines.extend([
                "‚úÖ TECHNICAL COMPLETENESS VALIDATION:",
                f"  ‚Ä¢ Completeness Score: {completeness.get('completeness_score_percent', 'N/A')}%",
                f"  ‚Ä¢ Winding Resistance Complete: {completeness.get('winding_resistance_complete', 'Unknown')}",
                f"  ‚Ä¢ Turns Ratio Complete: {completeness.get('turns_ratio_complete', 'Unknown')}",
                f"  ‚Ä¢ Tan Delta Complete: {completeness.get('tan_delta_complete', 'Unknown')}",
                f"  ‚Ä¢ Bushing Analysis Complete: {completeness.get('bushing_analysis_complete', 'Unknown')}",
                f"  ‚Ä¢ Demagnetization Complete: {completeness.get('demagnetization_complete', 'Unknown')}",
                f"  ‚Ä¢ Technical Completeness Verified: {completeness.get('technical_completeness_verified', 'Unknown')}",
                ""
            ])
    
    # Footer
    report_lines.extend([
        "",
        "=" * 80,
        f"üïí Report Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        "ü§ñ TRAX AI Analyzer v3.0 - Comprehensive JSON-Driven Report",
        "=" * 80
    ])
    
    # Write the report
    os.makedirs(os.path.dirname(output_file_path), exist_ok=True)
    with open(output_file_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(report_lines))
    
    return output_file_path

def batch_regenerate_reports(json_directory, output_directory):
    """
    Regenerate all reports from JSON files in a directory
    """
    regenerated_files = []
    
    for filename in os.listdir(json_directory):
        if filename.endswith('.json'):
            json_path = os.path.join(json_directory, filename)
            # Create corresponding report filename
            report_filename = filename.replace('.json', '_comprehensive_report.txt')
            output_path = os.path.join(output_directory, report_filename)
            
            try:
                generate_detailed_report_from_json(json_path, output_path)
                regenerated_files.append(output_path)
                print(f"‚úÖ Generated: {report_filename}")
            except Exception as e:
                print(f"‚ùå Error processing {filename}: {e}")
    
    return regenerated_files

if __name__ == "__main__":
    # Example usage
    json_dir = "../Projects/TRAX_Reports/JSON_Data"
    output_dir = "../Projects/TRAX_Reports/Comprehensive_Reports"
    
    print("üîÑ Regenerating comprehensive reports from JSON data...")
    files = batch_regenerate_reports(json_dir, output_dir)
    print(f"\n‚úÖ Generated {len(files)} comprehensive reports!")